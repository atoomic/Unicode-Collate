#!perl
#
# This auxiliary script makes locale .pl files
# used by Unicode::Collate::Locale.
#
# Usage:
#    <do 'mklocale'> in perl, or <perl mklocale> in command line
#
# Input files:
#    data/*.txt
#    Collate/allkeys.txt
#
# Output files:
#    Locale/*.pl
#   (need to be moved to Collate/Locale/*.pl to install them)
#
# == Examples of the Rules ==
#
# 00F1;n+1 ===> primary weight of 00F1 is greater than that of n by 1.
#    Among literals, only [A-Za-z] can be the base.
#    +1  primary weight greater by 1.
#    -1  primary weight lesser by 1.
#    ++1 and --1 for secondary weight, +++1 and ---1 for tertiary weight.
#    a number followed by + or - is decimal.
#
# 01FD;<00E6><0301> ===> U+01FD eq U+00E6,U+0301
#    <XXXX> can be the base followed by +1 etc.
#    Ex. 1D2D;<00C6>+++12
#
# 0064 0335;=
# 0111;d++1<0335>
#    '=' saves DUCET weights as it is.
#    0064 0335;= prevents 0064 0335 from being equal to 0111.
#
# {ch};c+1   ===> 0063 0068;c+1
# {K'};Q++1  ===> 004B 0027;Q++1
#     { } before ; encloses a literal: [A-Za-z'] (alphabets or apostrophe).
#
# backwards
#    backwards => 2
#
# upper
#    upper_before_lower => 1
#
use 5.006;
use strict;
use warnings;
use Carp;
use File::Spec;

BEGIN {
    unless ("A" eq pack('U', 0x41)) {
	die "Unicode::Collate cannot stringify a Unicode code point\n";
    }
}

sub _getHexArray { map hex, $_[0] =~ /([0-9a-fA-F]+)/g }
sub trim { $_[0] =~ s/^\ +//; $_[0] =~ s/\ +\z// }

our $PACKAGE = 'Unicode::Collate, locale';
our $ENT_FMT = "%-9s ; %s # %s\n";
our $RE_CE   = '(?:\[[0-9A-Fa-f\.]+\])';

my (%Keys, %Code, %Equiv, %Name, $vDUCET);
my @OtherEquiv = split /\n=/, <<'OTHEREQUIV';
=00C2=
1EA7;<00E2><0300>
1EA6;<00C2><0300>
1EA5;<00E2><0301>
1EA4;<00C2><0301>
1EAB;<00E2><0303>
1EAA;<00C2><0303>
1EA9;<00E2><0309>
1EA8;<00C2><0309>
1EAD;<00E2><0323>
1EAC;<00C2><0323>
=00C4=
01DF;<00E4><0304>
01DE;<00C4><0304>
=00C5=
01FB;<00E5><0301>
01FA;<00C5><0301>
=00C6=
1D2D;<00C6>+++12
01FD;<00E6><0301>
01FC;<00C6><0301>
01E3;<00E6><0304>
01E2;<00C6><0304>
=00CA=
1EC1;<00EA><0300>
1EC0;<00CA><0300>
1EBF;<00EA><0301>
1EBE;<00CA><0301>
1EC5;<00EA><0303>
1EC4;<00CA><0303>
1EC3;<00EA><0309>
1EC2;<00CA><0309>
1EC7;<00EA><0323>
1EC6;<00CA><0323>
=00D4=
1ED3;<00F4><0300>
1ED2;<00D4><0300>
1ED1;<00F4><0301>
1ED0;<00D4><0301>
1ED7;<00F4><0303>
1ED6;<00D4><0303>
1ED5;<00F4><0309>
1ED4;<00D4><0309>
1ED9;<00F4><0323>
1ED8;<00D4><0323>
=00D6=
022B;<00F6><0304>
022A;<00D6><0304>
=00D8=
01FF;<00F8><0301>
01FE;<00D8><0301>
=00DC=
01DC;<00FC><0300>
01DB;<00DC><0300>
01D8;<00FC><0301>
01D7;<00DC><0301>
01D6;<00FC><0304>
01D5;<00DC><0304>
01DA;<00FC><030C>
01D9;<00DC><030C>
=0102=
1EB1;<0103><0300>
1EB0;<0102><0300>
1EAF;<0103><0301>
1EAE;<0102><0301>
1EB5;<0103><0303>
1EB4;<0102><0303>
1EB3;<0103><0309>
1EB2;<0102><0309>
1EB7;<0103><0323>
1EB6;<0102><0323>
=01A0=
1EDD;<01A1><0300>
1EDC;<01A0><0300>
1EDB;<01A1><0301>
1EDA;<01A0><0301>
1EE1;<01A1><0303>
1EE0;<01A0><0303>
1EDF;<01A1><0309>
1EDE;<01A0><0309>
1EE3;<01A1><0323>
1EE2;<01A0><0323>
=01AF=
1EEB;<01B0><0300>
1EEA;<01AF><0300>
1EE9;<01B0><0301>
1EE8;<01AF><0301>
1EEF;<01B0><0303>
1EEE;<01AF><0303>
1EEC;<01AF><0309>
1EED;<01B0><0309>
1EF0;<01AF><0323>
1EF1;<01B0><0323>
=01B7=
01EF;<0292><030C>
01EE;<01B7><030C>
=0301=
00E1;a<0301>
00C1;A<0301>
00E9;e<0301>
00C9;E<0301>
00ED;i<0301>
00CD;I<0301>
00F3;o<0301>
00D3;O<0301>
00FA;u<0301>
00DA;U<0301>
00FD;y<0301>
00DD;Y<0301>
=0303=
00E3;a<0303>
00C3;A<0303>
1EBD;e<0303>
1EBC;E<0303>
0129;i<0303>
0128;I<0303>
00F5;o<0303>
00D5;O<0303>
0169;u<0303>
0168;U<0303>
1EF9;y<0303>
1EF8;Y<0303>
=0309=
1EA3;a<0309>
1EA2;A<0309>
1EBB;e<0309>
1EBA;E<0309>
1EC9;i<0309>
1EC8;I<0309>
1ECF;o<0309>
1ECE;O<0309>
1EE7;u<0309>
1EE6;U<0309>
1EF7;y<0309>
1EF6;Y<0309>
=0323=
1EA1;a<0323>
1EA0;A<0323>
1EB9;e<0323>
1EB8;E<0323>
1ECB;i<0323>
1ECA;I<0323>
1ECD;o<0323>
1ECC;O<0323>
1EE5;u<0323>
1EE4;U<0323>
1EF5;y<0323>
1EF4;Y<0323>
OTHEREQUIV

my %OtherEquiv;
for my $o (@OtherEquiv) {
    my @ln = split /\n/, $o;
    my $uv = shift @ln;
    $uv =~ tr/=//d;
    $OtherEquiv{$uv} = \@ln;
}

{
    my($f, $fh);
    foreach my $d ('.') {
	$f = File::Spec->catfile($d, "Collate", "allkeys.txt");
	last if open($fh, $f);
	$f = undef;
    }
    croak "$PACKAGE: Collate/allkeys.txt is not found" if !defined $f;

    while (my $line = <$fh>) {
	chomp $line;
	next if $line =~ /^\s*#/;
	$vDUCET = $1 if $line =~ /^\@version\s*(\S*)/;

	next if $line !~ /^\s*[0-9A-Fa-f]/;

	my $name = '';
	$line =~ s/[#%]\s*(.*)// and $name = $1;

	# gets element
	my($e, $k) = split /;/, $line;
	trim($e);
	trim($k);
	$name =~ s/; QQ(?:CM|KN)//;

	next if $k eq '[.0000.0000.0000.0000]';

	croak "Wrong Entry: <charList> must be separated by ';' ".
	      "from <collElement>" if ! $k;
	push @{ $Equiv{$k} }, $e if exists $Code{$k};

	$Keys{$e} = $k;
	$Code{$k} = $e;
	$Name{$e} = $name;
    }
}
opendir DIR, "data" or croak "no data";
my @txts = grep !/^\./, readdir DIR;
closedir DIR;

mkdir 'Locale', 0666;
for my $txt (@txts) {
    my($fh, $ph);
    my %locale_keys;
    my $txtfile = File::Spec->catfile('data', $txt);
    my $pl = $txt;
       $pl =~ s/\.txt\z/.pl/ or croak "$PACKAGE: data/$txt is not .txt";
    my $plfile = File::Spec->catfile('Locale', $pl);

    open($fh, $txtfile) or croak "$PACKAGE: data/$txt is not found";
    open($ph, ">$plfile") or croak "$PACKAGE: locale/$pl can't be made";

    print $ph "+{\n";
    my $entry = '';
    while (<$fh>) {
	if (/^backwards$/) {
	    print $ph "   backwards => 2,\n";
	    next;
	}
	if (/^upper$/) {
	    print $ph "   upper_before_lower => 1,\n";
	    next;
	}
	if (/^\s*(#\s*)/) {
	    print $ph $_ if $1 ne '#';
	    next;
	}

	my($e,$rule) = split_e_rule($_);
	my $name = getname($e);
	my $eq_rule = $rule eq '=';
	$rule = join '', map "<$_>", split ' ', $e if $eq_rule;
	my ($newce, $simpdec) = parserule($e, $rule, \%locale_keys);
	$entry .= sprintf $ENT_FMT, $e, $newce, $name if !$eq_rule;
	$locale_keys{$e} = $newce;

	if (!$simpdec && $Keys{$e}) { # duplicate for the decomposition
	    my $key = $Keys{$e};
	    my @ce = $key =~ /$RE_CE/go;
	    if (@ce > 1) {
		my $ok = 1;
		my $ee = '';
		for my $c (@ce) {
		    $ok = 0, last if !$Code{$c};
		    $ee .= ' ' if $ee ne '';
		    $ee .= $Code{$c};
		}
		if ($ok && !$locale_keys{$ee}) {
		    $entry .= sprintf $ENT_FMT, $ee, $newce, $name;
		    $locale_keys{$ee} = $newce;
		}
	    }
	    if ($Equiv{$key}) {
		for my $eq (@{ $Equiv{$key} }) {
		    $entry .= sprintf $ENT_FMT, $eq, $newce, $Name{$eq};
		    $locale_keys{$eq} = $newce;
		}
	    }
	}

	if ($OtherEquiv{$e}) {
	    for my $o (@{ $OtherEquiv{$e} }) {
		my($e,$rule) = split_e_rule($o);
		my $name = getname($e);
		(my $newce, undef) = parserule($e, $rule, \%locale_keys);
		$entry .= sprintf $ENT_FMT, $e, $newce, $name;
		$locale_keys{$e} = $newce;
	    }
	}
    }
    if ($entry) {
	my $v = $vDUCET ? " # for DUCET v$vDUCET" : '';
	print $ph "   entry => <<'ENTRY',$v\n";
	print $ph $entry;
	print $ph "ENTRY\n";
    }
    print $ph "};\n";
    close $fh;
    close $ph;
}

sub getunicode {
    my $c = shift;
    my @c = split //, $c;
    return join ' ', map { sprintf '%04X', unpack 'U', $_ } @c;
}

sub split_e_rule {
    my $line = shift;
    chomp $line;
    my($e, $r) = split /;/, $line;
    $e =~ s/\{([A-Za-z']+)\}/' '.getunicode($1).' '/ge;
    $e =~ s/ +/ /g;
    trim($e);
    return ($e, $r);
}

sub getname {
    my $e = shift;
    return $Name{$e} if $Name{$e};  # single codepoint without <>
    my @e = split ' ', $e;
    my @name = map { $Name{$_} ? $Name{$_} : 'unknown' } @e;
    return sprintf '<%s>', join ', ', @name;
}

sub parserule {
    (my $e   = shift) =~ s/ .*\z//;
    my $rule = shift;
    my $lockeys = shift;
    my $result = '';
    my $simple_decomp = 1; # rules containing only [A-Za-z] or <XXXX>

    for (my $prerule = $rule; $rule ne ''; $prerule = $rule) {
	$rule =~ s/^ +//;
	if ($rule =~ s/^($RE_CE)//o) {
	    $result .= $1;
	    next;
	}

	my $key;
	if ($rule =~ s/^(<[0-9A-Fa-f]+>|[A-Za-z])//) {
	    my $c = $1;
	    $c = getunicode($c) if $c !~ tr/<>//d;
	    croak "<$c> is too short" if 4 > length $c;
	    $key = $lockeys->{$c} || $Keys{$c};
	}

	my @base;
	for my $k ($key =~ /$RE_CE/go) {
	    push @base, [_getHexArray($k)];
	}
	croak "the rule seems wrong at $prerule" if !@base;

	my $replaced = 0;
	while ($rule =~ s/^(([+-])\2*)(\d+)//) {
	    my $idx = length($1) - 1;
	    my $num = $2 eq '-' ? -$3 : $3;
	    $base[0][$idx] += $num;
	    ++$replaced;
	}

	$simple_decomp = 0 if $replaced;
	for my $c (@base) {
	    $c->[3] = hex $e if $replaced;
	    my $keys = '[.'.join('.', map { sprintf '%04X', $_ } @$c).']';
	    $result .= $keys;
	}
	croak "something wrong at $rule" if $prerule eq $rule;
    }
    return($result, $simple_decomp);
}
